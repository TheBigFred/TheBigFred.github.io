
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="index, follow">

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://thebigfred.github.io/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="https://thebigfred.github.io/theme/pygments/monokai.min.css">
  <link rel="stylesheet" type="text/css" href="https://thebigfred.github.io/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://thebigfred.github.io/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://thebigfred.github.io/theme/font-awesome/css/solid.css">


    <link href="https://thebigfred.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="fgeDoc's Atom">




    <!-- Chrome, Firefox OS and Opera -->
    <meta name="theme-color" content="#333333">
    <!-- Windows Phone -->
    <meta name="msapplication-navbutton-color" content="#333333">
    <!-- iOS Safari -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Microsoft EDGE -->
    <meta name="msapplication-TileColor" content="#333333">

<meta name="author" content="FGE">
<meta name="description" content="CMake est un outil open-source et cross-platform qui permet la gestion du processus de compilation d&#39;une application et ce de manière indépendante du système d&#39;exploitation …">
<meta name="keywords" content="cmd-line, GNU-Tools">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<meta property="og:site_name" content="fgeDoc's"/>
<meta property="og:title" content="Introduction à CMake"/>
<meta property="og:description" content="CMake est un outil open-source et cross-platform qui permet la gestion du processus de compilation d&#39;une application et ce de manière indépendante du système d&#39;exploitation …"/>
<meta property="og:locale" content="fr_BE"/>
<meta property="og:url" content="https://thebigfred.github.io/drafts/introduction-a-cmake.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2019-04-29 19:43:00+02:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="https://thebigfred.github.io/author/fge.html">
<meta property="article:section" content="devtools"/>
<meta property="article:tag" content="cmd-line"/>
<meta property="article:tag" content="GNU-Tools"/>
<meta property="og:image" content="">

  <title>fgeDoc's &ndash; Introduction à CMake</title>

</head>
<body>
  <aside>
    <div>
      <h1><a href="https://thebigfred.github.io/index.html">FGE Doc's</a></h1>

<p>Sharing notes</p>      <nav>
        <h2>
          <a href="https://thebigfred.github.io/index.html">
            <span class="fa fa-home"></span>
            <small> Home</small>
          </a>
        </h2>
        <ul class="list">
        </ul>
      </nav>
      <nav>
        <h2>
          <a href="https://thebigfred.github.io/categories.html">
            <span class="fa fa-folder-open"></span>
            <small> Catégories</small>
          </a>
        </h2>
	      <ul class="list">
          <li><a href="https://thebigfred.github.io/category/devtools.html">devtools (5)</a></li>
          <li><a href="https://thebigfred.github.io/category/linux.html">linux (4)</a></li>
        </ul>
      </nav>
      <nav>
        <h2>
          <a href="https://thebigfred.github.io/tags.html">
            <span class="fa fa-tags"></span>
            <small> Tags</small>
          </a>
        </h2>
        <ul class="list">          <li><a href="https://thebigfred.github.io/tag/cmd-line.html">cmd-line (6)</a></li>
          <li><a href="https://thebigfred.github.io/tag/gnu-tools.html">GNU-Tools (5)</a></li>
          <li><a href="https://thebigfred.github.io/tag/xfce4.html">XFCE4 (1)</a></li>
          <li><a href="https://thebigfred.github.io/tag/xorg.html">Xorg (2)</a></li>
        </ul>
      </nav>
      <ul class="social">
          <li>
            <a  class="sc-linkedin" href="https://be.linkedin.com/in/frederic-gerard-32092754" target="_blank">
            <i class="fab fa-linkedin">
            </i>
          </a></li>
          <li>
            <a  class="sc-rss" href="https://thebigfred.github.io/feeds/all.atom.xml" target="_blank">
            <i class="fas fa-rss">
            </i>
          </a></li>
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href="https://thebigfred.github.io/index.html"><span class="fa fa-home"> Home</a>
  - <span class="fa fa-folder-open-o" ></span> devtools
      <hr>
    </nav>

<article class="single">
  <header>
      <div class="toc"><span class="toctitle">Content</span><ul>
<li><a href="#1-concepts-de-base">1. Concepts de base</a></li>
<li><a href="#2-pre-requis">2. Pré-requis</a></li>
<li><a href="#3-installation-de-cmake">3. Installation de cmake</a></li>
<li><a href="#4-generation-dun-projet">4. Génération d'un projet</a><ul>
<li><a href="#41-choix-du-generateur">4.1 Choix du générateur</a></li>
<li><a href="#42-choix-du-type-de-compilation">4.2 Choix du type de compilation</a></li>
<li><a href="#44-utiliser-la-commande-cmake-a-la-place-de-make-ou-ninja">4.4 Utiliser la commande cmake à la place de make ou ninja</a></li>
<li><a href="#45-preset">4.5 Preset</a></li>
</ul>
</li>
<li><a href="#5-application-simple">5. Application simple</a></li>
<li><a href="#6-outils-du-langage-cmake">6 Outils du langage cmake</a><ul>
<li><a href="#61-variables">6.1 Variables</a></li>
<li><a href="#62-les-listes">6.2 Les listes</a></li>
<li><a href="#63-afficher-des-messages">6.3 Afficher des messages</a></li>
<li><a href="#64-generation-de-fichiers">6.4 Génération de fichiers</a></li>
<li><a href="#65-gestion-doptions">6.5 Gestion d'options</a></li>
<li><a href="#66-les-conditions">6.6 Les conditions</a></li>
<li><a href="#67-custom_target">6.7 custom_target</a></li>
</ul>
</li>
<li><a href="#7-une-application-qui-utilise-des-bibliotheques">7 Une application qui utilise des bibliothèques</a></li>
<li><a href="#8-creer-une-bibliotheques">8 Créer une bibliothèques</a><ul>
<li><a href="#81-statique-ou-partagee">8.1 Statique ou partagée</a></li>
<li><a href="#82-statique-et-partagee">8.2 Statique et partagée</a></li>
<li><a href="#83-visibilite-des-symboles-dune-bibliotheques-partagee">8.3 Visibilité des symboles d'une bibliothèques partagée</a></li>
<li><a href="#84-exporter-sa-bibliotheque">8.4 Exporter sa bibliothèque</a></li>
<li><a href="#85-une-bibliotheque-avec-dependances">8.5 Une bibliothèque avec dépendances</a></li>
</ul>
</li>
<li><a href="#9-tests-unitaires">9 Tests unitaires</a></li>
<li><a href="#10-documentation">10 Documentation</a></li>
<li><a href="#11-packaging">11 Packaging</a></li>
<li><a href="#12-ne-pas-deployer-projet-de-projet">12 Ne pas déployer (Projet de projet)</a></li>
<li><a href="#13-organisation-des-sources">13 Organisation des sources</a></li>
<li><a href="#14-macros-et-fonctions">14 Macros et fonctions</a></li>
<li><a href="#15-parser-un-fichier">15 Parser un fichier</a></li>
<li><a href="#5-portee-des-variables-commandes-et-proprietes">5. Portée des variables, commandes et propriétés</a></li>
</ul>
</div>
      
    <h1 id="introduction-a-cmake">Introduction à CMake</h1>
    <p>
      Posté le lun 29 avril 2019 dans <a href="https://thebigfred.github.io/category/devtools.html">devtools</a>

        <br>Article de la série  :
    </p>
  </header>

  <div>
    
<p><img alt="cmake-gui" src="https://thebigfred.github.io/images/cmake-gui-icon-128px.png" style="float: left; margin: 5px;"/>
CMake est un outil open-source et cross-platform qui permet la gestion du processus de compilation d'une application et ce de manière indépendante du système d'exploitation, du compilateur utilisé et de l'IDE utilisé.</p>
<p>En bref, vous écrivez un fichier texte nommé CMakeLists.txt qui décrit votre projet et cmake vous générera un projet à base de makefile, ninja, un projet Eclipse, un projet Visual Studio, ...</p>
<p>Il est possible de construire des applications, des bibliothèques statiques et/ou partagées. Mais également de cross compiler, de générer des pacquages, d'exécuter des tests unitaires et d'autres choses.</p>
<p>Les langages supportés <em>out of the box</em> sont le C, C++, CUDA, Fortran et l'assembleur.</p>
<p>CMake est extensible par le biais de modules existants que l'on peut charger, ou par le biais de modules que l'on peut écrire soit même.</p>
<p>Il existe par exemple des modules permettant de prendre en charge d'autres langages comme python, java ou latex.</p>
<p>A mes débuts en cmake, l'inconvénient majeur était la documentation. Il n'y avait pas de tutoriel officiel. On trouve également beaucoup de tuto ou de post sur les forums avec des pratiques qualifiées de mauvaises depuis la version 3.0.</p>
<p>Depuis la version 3.0, on parle de <a href="https://cliutils.gitlab.io/modern-cmake"><em>Modern cmake</em></a> et c'est "la bonne pratique" à suivre. Depuis la version 3.16, il existe un <a href="https://cmake.org/cmake/help/v3.16/guide/tutorial/index.html">tuto officiel</a>.</p>
<h1 id="1-concepts-de-base">1. Concepts de base</h1>
<p>Voici quelques mots de vocabulaires à connaître avant d'aller plus loin.</p>
<p>Un <em>buildsystem</em> est un outil permettant de compiler un projet depuis son code source. Make et son fichier Makefile ou une solution Visual Studio en sont des exemples. CMake est un générateur de buildsystem. Il va permettre de ne pas devoir maintenir un Makefile et une solution Visual Studio pour un projet que l'on souhaite compiler sous Linux et sous Windows.</p>
<p><em>Source tree</em> désigne le dossier racine contenant les sources du projet.</p>
<p><em>Build tree</em> désigne le dossier racine dans lequel les artefacts de compilations et de cmake se trouveront.</p>
<p>Une <em>target</em> désigne un ensemble de commandes, de propriétés et de dépendances. Elles peuvent correspondre à un exécutable, une bibliothèque ou un ensemble de commandes quelconques. Il est possible d'exprimer des dépendances entre targets.</p>
<h1 id="2-pre-requis">2. Pré-requis</h1>
<p>Votre système d'exploitation doit disposer au minimum d'un compilateur et de l'outil make.</p>
<ul>
<li>Sous Windows, vous pouvez installer MinGW-W64 ou Visual C++.</li>
<li>Sous MacOS, installez "Xcode Command Line Tools".</li>
<li>Sous Linux, il y a généralement un méta-package nommé "build-essential".</li>
</ul>
<h1 id="3-installation-de-cmake">3. Installation de cmake</h1>
<p>Des versions binaires sont disponibles sur <a href="https://cmake.org/download/">cmake.org</a>. Je vous conseil d'utiliser la <em>Latest Release</em>.</p>
<p>Il faut noter que d'une version à l'autre de cmake, certain changement peuvent casser vos CMakeLists. Pensez à lire la release note avant de changer votre version de cmake.</p>
<p>Sous Linux, je procède comme suit pour gérer mes versions de cmake.</p>
<ol>
<li>Je download une version, par exemple <a href="https://github.com/Kitware/CMake/releases/download/v3.22.2/cmake-3.22.2-linux-x86_64.tar.gz">cmake-3.22.2-linux-x86_64.tar.gz</a>.</li>
<li>Je la décompresse dans le dossier /opt/kitware/cmake-3.22.2</li>
<li>Je crée un lien symbolique /opt/kitware/cmake qui redirige vers une des versions que j'ai installé.</li>
<li>J'ajoute le dossier /opt/kitware/cmake/bin au début de la variable d'environnement PATH.</li>
<li>J'ajoute cet export à la fin du fichier .bashrc (à ne faire qu'une fois).</li>
</ol>
<p>Ce qui donne en pratique :</p>
<pre><code>:::console
$ wget https://github.com/Kitware/CMake/releases/download/v3.22.2/cmake-3.22.2-linux-x86_64.tar.gz
$ sudo mkdir -p /opt/kitware
$ sudo tar xaf cmake-3.22.2-linux-x86_64.tar.gz -C /opt/kitware/cmake-3.22.2
$ sudo ln -s /opt/kitware/cmake-3.22.2 /opt/kitware/cmake
$ export PATH=/opt/kitware/cmake/bin:$PATH
$ cat &gt;&gt; ~/.bashrc &lt;&lt; EOF
&gt; CMAKE_PATH=/opt/kitware/cmake/bin
&gt; [[ -d $CMAKE_PATH &amp;&amp; ! $PATH =~ $CMAKE_PATH ]] &amp;&amp; export PATH=$CMAKE_PATH:$PATH
&gt; EOF
$
</code></pre>
<h1 id="4-generation-dun-projet">4. Génération d'un projet</h1>
<p>Placez-vous dans un dossier de travail, par exemple <em>$HOME/cmake/exp01</em>.</p>
<p>Écrivez le code suivant dans un fichier texte et nommez le <em>CMakeLists.txt</em>.</p>
<pre><code>:::cmake
cmake_minimum_required(VERSION 3.0.2)   # définit la version minimum de cmake
project(MonApplication)                 # Configure le nom du projet
add_executable(app01 main.cpp)          # Création d'une application app01 depuis main.cpp
</code></pre>
<p>Créez le fichier <em>main.cpp</em> suivant :</p>
<pre><code>:::CPP
int main()
{}
</code></pre>
<p>Dans une console, placez-vous dans le dossier contenant votre <em>CMakeLists.txt</em> et le fichier main.cpp. Tapez <strong>cmake .</strong></p>
<pre><code>:::console
$ cmake .
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc - works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ - works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/fred/cmake/exp01
$
</code></pre>
<p>Nous venons de générer un projet makefile.</p>
<pre><code>:::console
$ ls -l
CMakeCache.txt         
CMakeFiles
cmake_install.cmake
CMakeLists.txt         # Notre fichier CMakeLists.txt
main.cpp               # Les sources de notre application
Makefile               # Le makefile généré
</code></pre>
<p>Comme on le voit, cmake à généré un dossier et plusieurs fichiers dont un Makefile.
Il n'y a plus qu'à compiler notre application grace à make.</p>
<pre><code>:::console
$ make
Scanning dependencies of target app01
[ 50%] Building CXX object CMakeFiles/app01.dir/main.cpp.o
[100%] Linking CXX executable app01
[100%] Built target app01
$
</code></pre>
<p>Une manière plus <em>propre</em> de travailler est de générer les fichiers cmake dans un répertoire différent.
Soit dans un sous dossier des sources, soit un dossier en dehors des sources.</p>
<p>Il y a quatre manières de procéder :</p>
<ul>
<li>Vous vous placez dans le dossier de <em>compilation</em> et vous indiquez à cmake où se trouve le fichier CMakeLists.txt.</li>
<li>Vous utilisez les options -S et -B de cmake pour indiquer respectivement, le dossier des sources et le de dossier de build.</li>
<li>Vous utilisez l'interface cmake-gui (sera abordé en annexe).</li>
<li>Vous utilisez l'interface de votre IDE.</li>
</ul>
<blockquote>
<p>Supprimer les fichiers générés entre chaque exemple.</p>
</blockquote>
<h3 id="methode-1">Méthode 1</h3>
<pre><code>:::console
$ cd $HOME/cmake/exp01      # Le dossier des sources
$ mkdir build               # Création d'un sous dossier de compilation
$ cd build                  # On se déplace dans le dossier build
$ cmake ..                  # Exécution de cmake avec le path (ici relatif) des sources
$ make                      # Compilation du projet
...
</code></pre>
<p>Ou encore</p>
<pre><code>:::console
$ mkdir $HOME/build         # Création d'un dossier de compilation hors des sources
$ cd $HOME/build            # On se déplace dans le dossier build
$ cmake $HOME/cmake/exp01   # Exécution de cmake avec le path absolu des sources
$ make                      # Compilation du projet
...
</code></pre>
<h3 id="methode-2">Méthode 2</h3>
<pre><code>:::console
$ mkdir $HOME/build                           # Création d'un dossier de compilation hors des sources
$ cmake -S $HOME/cmake/exp01 -B $HOME/build   # Exécution de cmake
$ cd $HOME/build                              # On se déplace dans le dossier build
$ make                                        # Compilation du projet
...
</code></pre>
<!-- ### Méthode 3 : cmake-gui

CMake propose une interface graphique qui permet de générer un projet.
Il suffit d'indiquer le dossier contenant les sources et un dossier de build.
Cliquer ensuite sur le bouton configure.

![cmake-gui - choix du générateur de projet]({static}/images/cmake-gui-1.png)

Une nouvelle fenêtre apparaît, elle vous demande le type de projet que vous souhaitez générer ainsi que le compilateur à utiliser.

Ces paramètres peuvent également être indiquer via la ligne de commande. Nous aborderons cela plus loin.

![cmake-gui - choix du générateur de projet]({static}/images/cmake-gui-2.png)
![cmake-gui - configure]({static}/images/cmake-gui-3.png)
![cmake-gui - generate]({static}/images/cmake-gui-4.png) -->
<h2 id="41-choix-du-generateur">4.1 Choix du générateur</h2>
<p>Pour obtenir la liste des générateurs disponible, placez-vous dans une console et tapez <strong>cmake -G</strong></p>
<pre><code>:::console
$ cmake -G
CMake Error: No generator specified for -G

Generators
* Unix Makefiles             = Generates standard UNIX makefiles.
Green Hills MULTI            = Generates Green Hills MULTI files
                               (experimental, work-in-progress).
Ninja                        = Generates build.ninja files.
Ninja Multi-Config           = Generates build-&lt;Config&gt;.ninja files.
Watcom WMake                 = Generates Watcom WMake makefiles.
CodeBlocks - Ninja           = Generates CodeBlocks project files.
CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files.
CodeLite - Ninja             = Generates CodeLite project files.
CodeLite - Unix Makefiles    = Generates CodeLite project files.
Sublime Text 2 - Ninja       = Generates Sublime Text 2 project files.
Sublime Text 2 - Unix Makefiles
                             = Generates Sublime Text 2 project files.
Kate - Ninja                 = Generates Kate project files.
Kate - Unix Makefiles        = Generates Kate project files.
Eclipse CDT4 - Ninja         = Generates Eclipse CDT 4.0 project files.
Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files.
</code></pre>
<p>Unix Makefiles est le choix par défaut. Pour utiliser <em>Ninja</em>, on fera donc:</p>
<pre><code>:::console
$ cmake -G"Ninja" -S $HOME/cmake/exp01 -B $HOME/build
...
</code></pre>
<p>La liste des générateurs disponible varie en fonction du système (Windows, MacOs, Linux).</p>
<h2 id="42-choix-du-type-de-compilation">4.2 Choix du type de compilation</h2>
<p>Lorsque l'on compile un projet, on souhaite pourvoir modifier certains 'flags' de compilation.
Comme par exemple :</p>
<ul>
<li>le niveau d'optimisations -O0 ou -O2 ;</li>
<li>ajouter les symboles au binaire avec l'option -g ;</li>
<li>activer ou désactiver certaines traces dans le code.</li>
</ul>
<p>On parle généralement de configuration du code en mode 'Debug' ou en mode 'Release'.</p>
<p>La manière de configurer ce mode est influencé par le générateur utilisé.</p>
<p>CMake propose deux types de générateurs :</p>
<ul>
<li>les générateurs à configuration unique (single-configuration generators), comme "Unix Makefile" ou "Ninja" ;</li>
<li>les générateurs multi-configuration (multi-configuration generators), comme "Ninja Multi-Config", "Visual Studio" ou "Xcode".</li>
</ul>
<p>Pour les <em>single-configuration generators</em>, le type de compilation est choisi à la génération du projet.</p>
<p>La variable <strong>CMAKE_BUILD_TYPE</strong> permet de choir le type de build, elle peut valoir : <em>Debug</em>, <em>Release</em>, <em>RelWithDebInfo</em> ets <em>MinSizeRel</em>.
Des valeurs customisées peuvent être définies.</p>
<p>En fonction du langage et du compilateur utilisé, les options par défaut des différents types de build peuvent varier.</p>
<p>Si l'on ne spécifie pas le type de build, une valeur par défaut est choisie en fonction du langage et du compilateur utilisé.</p>
<p>Pour les <em>multi-configuration generators</em>, le type de compilation est choisi lors de la compilation.</p>
<p>La variable <strong>CMAKE_CONFIGURATION_TYPES</strong> reprendre la liste des configurations disponibles. La variable <strong>CMAKE_BUILD_TYPE</strong> est simplement ignorée.</p>
<p>Il ne faut donc jamais utilisé la variable <strong>CMAKE_BUILD_TYPE</strong> dans vos CMakeLists pour déterminer le type de build, à la place, on utilisera un générateur d'expression comme par exemple <em>$&lt;CONFIG:DEBUG&gt;</em>.</p>
<blockquote>
<p>Notez que le générateur d'expression n'est pas sensible à la case, <em>$&lt;CONFIG:DEBUG&gt;</em> est donc équivalent à <em>$&lt;CONFIG:Debug&gt;</em>.
Notez également que le générateur d'expression est évalué lors de la compilation et non lors de la génération du projet.</p>
</blockquote>
<p>Illustrons tout ceci. Placez-vous dans un dossier de travail, <em>$HOME/cmake/exp02</em>.</p>
<p>Recopier le fichier main.cpp de l'exemple 01 et écrivez le code suivant dans le fichier <em>CMakeLists.txt</em>.</p>
<pre><code>:::cmake
cmake_minimum_required(VERSION 3.0.2)
project(MonApplication)
add_executable(app02 main.cpp)

message(STATUS "CMAKE_BUILD_TYPE          : ${CMAKE_BUILD_TYPE}")
message(STATUS "CMAKE_CONFIGURATION_TYPES : ${CMAKE_CONFIGURATION_TYPES}")
message(STATUS "CMAKE_CXX_FLAGS_DEBUG     : ${CMAKE_CXX_FLAGS_DEBUG}")
message(STATUS "CMAKE_CXX_FLAGS_RELEASE   : ${CMAKE_CXX_FLAGS_RELEASE}")

add_custom_target(print_config ALL
    COMMAND ${CMAKE_COMMAND} -E echo "Config is $&lt;CONFIG&gt;"
)
</code></pre>
<p>Ce CMakeLists.txt affichera 4 messages permettant de voir le contenu de 4 variables.
<em>add_custom_target</em> (qui sera abordé plus tard) nous permet d'afficher la valeur de $&lt;CONFIG&gt; lors de la compilation.</p>
<p>J'utilise la "méthode 1" pour générer les projets.</p>
<pre><code>:::console
$ cd $HOME/cmake/exp02
$ mkdir build
$ cd build
$ cmake cmake -G"Ninja" -DCMAKE_BUILD_TYPE=Debug ..
...
-- CMAKE_BUILD_TYPE          : Debug
-- CMAKE_CONFIGURATION_TYPES : 
-- CMAKE_CXX_FLAGS_DEBUG     : -g
-- CMAKE_CXX_FLAGS_RELEASE   : -O3 -DNDEBUG
...
$ ninja
...
Config is Debug
...
$ rm -rf *
$ cmake -G"Ninja Multi-Config" -DCMAKE_CONFIGURATION_TYPES="Debug;Release" ..
...
-- CMAKE_BUILD_TYPE          : 
-- CMAKE_CONFIGURATION_TYPES : Debug;Release
-- CMAKE_CXX_FLAGS_DEBUG     : -g
-- CMAKE_CXX_FLAGS_RELEASE   : -O3 -DNDEBUG
...
$ ninja -f build-Debug.ninja
...
Config is Debug
...
$ ninja -f build-Release.ninja
...
Config is Release
...
</code></pre>
<p>Dans le cas de <em>Ninja Multi-Config</em>, cmake à généré autant de fichiers build-&lt;CONFIG&gt;.ninja que ce qu'il y a de valeurs dans <em>CMAKE_CONFIGURATION_TYPES</em>.</p>
<h2 id="44-utiliser-la-commande-cmake-a-la-place-de-make-ou-ninja">4.4 Utiliser la commande cmake à la place de make ou ninja</h2>
<p>Une fois notre projet généré, nous nous sommes placé dans le dossier de build et avons utilisé la commande <code>make</code> ou <code>ninja</code>.</p>
<p>Il est possible de lancer la compilation de manière indépendante du générateur choisi. La syntaxe est la suivante : <code>cmake --build &lt;dir&gt; [&lt;options&gt;] [-- &lt;build-tool-options&gt;]</code>.</p>
<p>Les options sont :</p>
<ul>
<li>
<p>-t &lt;target_name&gt; ou --target &lt;target_name&gt; : permet de préciser la target à compiler. Plusieurs targets peuvent être indiquée en les séparent d'un espace.</p>
</li>
<li>
<p>--config &lt;config_name&gt; : permet de choisir la configuration pour <em>multi-configuration generators</em>.</p>
</li>
<li>
<p>--clean-first : appel la target clean avant de lancer le build.</p>
</li>
<li>
<p>-j [&lt;nb_jobs&gt;] ou --parallel [<nb_jobs>] : disponible depuis la version 3.12, indique le nombre maximum de tâches qui peuvent être effectuées en parallèle. Si l'on indique pas &lt;nb_jobs&gt;, le nombre par défaut du générateur est utilisé. La variable <em>CMAKE_BUILD_PARALLEL_LEVEL</em> permet de spécifier une valeur par défaut si cette option n'est pas présente.</nb_jobs></p>
</li>
</ul>
<h2 id="45-preset">4.5 Preset</h2>
<p>Un des inconvénients de cmake est le partage de la ligne de commande à utiliser pour configurer correctement un projet.
Pour l'instant, nous ne connaissons que le paramètre <em>CMAKE_BUILD_TYPE</em>, mais on peut en avoir facilement de 3 à 5.</p>
<p>Avant la version 3.19 de cmake, on écrivait donc un petit scripts contenant la ligne de commande cmake.</p>
<p>Depuis cmake 3.19, on peut utiliser deux fichiers <em>CMakePresets.json</em> et <em>CMakeUserPresets.json</em> pour stocker et partager ces paramètres.</p>
<p>Ces deux fichiers doivent être stockés dans le dossier racine du projet, avec le fichier CMakeLists.txt. Ils ont le même format et au minimum un seul des deux est requit si vous utilisez l'option <em>--preset</em> de cmake.</p>
<p>CMakePresets.json est destiné à être utiliser avec votre CI par exemple, tandis que CMakeUserPresets.json est destiné à stocker des détailles spécifiques et local au développeur. Il est conseillé d'ajouter CMakeUserPresets.json au fichier .gitignore.</p>
<p>Placer le contenu suivant dans le fichier CMakePreset.json</p>
<p>:::json
   {
      "version": 1,
      "configurePresets": [
         {
            "name": "release",
            "binaryDir": "${sourceDir}/_build-${presetName}",
            "generator": "Ninja",
            "cacheVariables": {
               "CMAKE_BUILD_TYPE": "Release"
            }
         }
      ]
   }</p>
<p>Pour configurer le projet, faite <code>cmake -S . --preset release</code></p>
<p>Le contenu des fichiers de preset évolue avec les versions de cmake et peut être assez conséquent. Pour aller plus loin, reportez vous à la <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">documentation</a>.</p>
<h1 id="5-application-simple">5. Application simple</h1>
<p>Cet exemple reprend les options classiques de gcc. On complétera ce canevas par la suite. Les fichiers sont disponible <a href="https://github.com/TheBigFred/tutoCmake"><em>ici</em></a>.</p>
<pre><code>:::cmake
cmake_minimum_required(VERSION 3.0.2)
project(app03 VERSION 1.2.3.4 LANGUAGES CXX)

# Définition de la target
add_executable(         # Equivalent de g++ -o app03 main.cpp pipotron.cpp pipotron.h
    ${PROJECT_NAME}     # Définition d'une target avec la variable cmake
                        # contenant le nom du projet, ici app03.
    main.cpp            # Liste des fichiers sources
    pipotron.cpp
    pipotron.h
)

# CXXFLAGS : Flags passés au compilateur
target_compile_options( ${PROJECT_NAME}
    PRIVATE
        # Attention : les flags gcc ne sont pas compatible avec tout les compilateurs !
        -Wall -Wextra
        $&lt;$&lt;CONFIG:DEBUG&gt;:-O0&gt;      # options utilisées uniquement en mode Debug
        $&lt;$&lt;CONFIG:RELEASE&gt;:-O3&gt;    # options utilisées uniquement en mode Release
)

# On force l'utilisation de C++11
set_target_properties( ${PROJECT_NAME}
    PROPERTIES 
        CXX_STANDARD          11
        CXX_STANDARD_REQUIRED YES
)

# Ajout d'un define, équivalent g++ -DDEBUG
target_compile_definitions( ${PROJECT_NAME}
    PRIVATE
        $&lt;$&lt;CONFIG:DEBUG&gt;:DEBUG&gt;    # Ajoute -DDEBUG uniquement en mode Debug
)

# On retire les symboles de l'exécutable
add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
    COMMAND ${CMAKE_OBJCOPY} --only-keep-debug ${PROJECT_NAME} ${PROJECT_NAME}.debug
    COMMAND ${CMAKE_OBJCOPY} --strip-debug ${PROJECT_NAME}
    COMMAND ${CMAKE_OBJCOPY} --add-gnu-debuglink=${PROJECT_NAME}.debug ${PROJECT_NAME}
)

# Directive d'installation
install(
    TARGETS         ${PROJECT_NAME}
    DESTINATION     bin
)
</code></pre>
<h3 id="cmake_minimum_required">cmake_minimum_required</h3>
<p>On en reparlera plus en détail plus loin, mais il est possible d'include d'autre CMakeLists.txt au votre.</p>
<p>Le cmake de plus haut niveau doit commencer par <strong><a href="https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html">cmake_minimum_required</a></strong> qui permet de définir la version minimum de cmake à utiliser.</p>
<p>Ce <em>top level</em> CMakeLists.txt doit également contenir explicitement une ligne <strong>project(...)</strong>, inclure un fichier qui contient une ligne <em>project(...)</em> n'est pas suffisant.</p>
<h3 id="project">project</h3>
<p>La commande <strong><a href="https://cmake.org/cmake/help/latest/command/project.html">project</a></strong> définit le nom du projet qui est stocké dans la variable <strong>PROJECT_NAME</strong>.</p>
<p>Définit les variables :</p>
<ul>
<li><strong>CMAKE_PROJECT_NAME</strong>    : uniquement dans le <em>top level</em> CMakeLists.txt</li>
<li><strong>PROJECT_IS_TOP_LEVEL</strong>  : booléen disponible depuis la version 3.21</li>
<li><strong>PROJECT_SOURCE_DIR</strong>    : le path du CMakeLists contenant la commande <em>project</em>.</li>
<li><strong>PROJECT_BINARY_DIR</strong>    : le path du dossier de build.</li>
</ul>
<p>Chacune des variables <strong>PROJECT_XXXXX</strong> sont déclinées en <strong>&lt;PROJECT_NAME&gt;_XXXXX</strong>,
ainsi  <strong>app03_SOURCE_DIR</strong> est l'équivalent de <strong>PROJECT_SOURCE_DIR</strong>.</p>
<p>L'option <em>VERSION</em> définit :</p>
<ul>
<li><strong>PROJECT_VERSION</strong>       : la version complète.</li>
<li><strong>PROJECT_VERSION_MAJOR</strong> : le 1ier digit de la version.</li>
<li><strong>PROJECT_VERSION_MINOR</strong> : le 2eme digit de la version.</li>
<li><strong>PROJECT_VERSION_PATCH</strong> : le 3eme digit de la version.</li>
<li><strong>PROJECT_VERSION_TWEAK</strong> : le 4eme digit de la version.</li>
<li><strong>CMAKE_PROJECT_VERSION</strong> : uniquement dans le <em>top level</em> CMakeLists.txt depuis la version 3.12.</li>
</ul>
<p>L'option <em>LANGUAGES</em>  permet de préciser les langages nécessaires à la compilation du projet.
Les langages supporté sont :</p>
<ul>
<li>C, CXX (C++), Fortran, ASM (Assembleur).</li>
<li>OBJC, OBJCXX (objective-C).</li>
<li><a href="https://developer.amd.com/resources/rocm-learning-center/fundamentals-of-hip-programming">HPI</a>, <a href="https://ispc.github.io/ispc.html">ISPC</a>, <a href="https://en.wikipedia.org/wiki/CUDA">CUDA</a></li>
</ul>
<p>Le support des différents langages est apparut au travers des différentes versions de CMake, il faut donc consulter la documentation pour indiquer la bonne version de cmake dans la commande <em>cmake_minimum_required</em>.</p>
<p>Les langages C et C++ sont activés par défaut si l'option <em>LANGUAGES</em> est absente.</p>
<p>Si votre projet mix des fichiers assembleurs et C++, alors lister ASM en dernier.
Cela permet à cmake de vérifier que votre compilateur C++ peut également compiler les fichiers assembleurs.</p>
<h3 id="creation-dun-executable">Création d'un exécutable</h3>
<p>La commande <strong><a href="https://cmake.org/cmake/help/latest/command/add_executable.html">add_executable</a></strong> prend en premier paramètre le nom de la target à créer suivit d'une liste (éventuellement vide) de fichiers.</p>
<p>Il peut évidement y a voir plusieurs target dans un même CMakeLists, elles doivent juste avoir des noms différents.</p>
<h3 id="options-de-compilation">Options de compilation</h3>
<p>La commande <strong><a href="https://cmake.org/cmake/help/latest/command/target_compile_options.html">target_compile_options</a></strong> définit les options passées au compilateur.</p>
<p>Évidement, tout les compilateurs n'ont pas des options identiques. Pour prendre cela an compte, il faut jouer avec des "if" ou avec la notation absconse du générateur d'expression cmake.</p>
<p>Dans l'exemple suivant, <em>if (MSVC)</em> est true si le compilateur est Microsoft Visual C++.</p>
<pre><code>:::cmake
if (MSVC)
    target_compile_options( ${PROJECT_NAME} PRIVATE /W4 /WX )
else()
    target_compile_options( ${PROJECT_NAME} PRIVATE -Wall -Wextra )
endif()
</code></pre>
<p>L'exemple suivant utilise le générateur d'expression.</p>
<pre><code>:::cmake
target_compile_options( ${PROJECT_NAME}
    PRIVATE
        # GCC Flags
        $&lt;$&lt;CXX_COMPILER_ID:GNU&gt;:-Wall -Wextra&gt;
        $&lt;$&lt;AND:$&lt;CONFIG:DEBUG&gt;,$&lt;CXX_COMPILER_ID:GNU&gt;&gt;:-O0 -ggdb&gt;
        $&lt;$&lt;AND:$&lt;CONFIG:RELEASE&gt;,$&lt;CXX_COMPILER_ID:GNU&gt;&gt;:-O2 -ggdb&gt;

        # MSVC Flags
        $&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;: /W4 /WX&gt;
        $&lt;$&lt;AND:$&lt;CONFIG:DEBUG&gt;,$&lt;CXX_COMPILER_ID:MSVC&gt;&gt;: /Od&gt;
        $&lt;$&lt;AND:$&lt;CONFIG:RELEASE&gt;,$&lt;CXX_COMPILER_ID:MSVC&gt;&gt;: /O2&gt;
)
</code></pre>
<p>$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt; se lit :</p>
<ul>
<li>Si la variable <strong>CXX_COMPILER_ID</strong> à la valeur <strong>MSVC</strong>.</li>
<li>Alors on ajoute les flags <strong>/W4 /WX</strong>.</li>
</ul>
<p>$&lt;$&lt;AND:$&lt;CONFIG:RELEASE&gt;,$&lt;CXX_COMPILER_ID:GNU&gt;&gt;:-O3 -ggdb&gt; se lit :</p>
<ul>
<li>Si le build est de type <strong>release</strong> et que la variable <strong>CXX_COMPILER_ID</strong> à la valeur <strong>GNU</strong>.</li>
<li>Alors on ajoute les flags <strong>-03 -ggdb</strong>.</li>
</ul>
<p>La liste des compilateurs disponibles varie d'une version de cmake à l'autre : <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER_ID.html">Compiler Id</a></p>
<p>Le mot clef <em>private</em> sera détaillé lorsque l'on abordera la création de bibliothèques.</p>
<h3 id="definition-du-standard-c">Définition du standard C++</h3>
<p>La seule méthode "valable" est celle reprise ci-dessus. Il n'est pas conseillé d'indiquer <em>-std=C++11</em> dans <strong>target_compile_options</strong>,
de manière générale, il faut éviter d'utiliser des options spécifiques à un compilateur et préférer utiliser une commande cmake.</p>
<p>Le tutoriel cmake officiel définit le standard de manière globale <strong>set(CMAKE_CXX_STANDARD 11)</strong>. Ce n'est pas recommandé, j'expliquerai pourquoi au point suivant.</p>
<p>En effet, rien ne nous empêche de créer plusieurs targets certaines utilisant du C++11 et d'autres du C++20.</p>
<h3 id="options-du-preprocesseur">Options du préprocesseur</h3>
<p>La commande <strong><a href="https://cmake.org/cmake/help/latest/command/target_compile_definitions.html">target_compile_definitions</a></strong> permet de définir (#define) ou supprimer (#undef) des variables (également nommé macro) au niveau du préprocesseur. En cmake, pour supprimer on fait précéder la macro de -D (D pour delete). Le <em>-D</em> de cmake correspond donc au _-U_de gcc.</p>
<pre><code>:::cmake
target_compile_definitions( ${PROJECT_NAME}
    PRIVATE
        $&lt;$&lt;CONFIG:DEBUG&gt;:DEBUG&gt;    # Correspond à "#define DEBUG" ou à g++ -DDEBUG
        SIZE=5                      # Correspond à "#define SIZE 5" ou à g++ -DSIZE=5
        -DTEST                      # Correspond à "#undef TEST" ou à g++ -UTEST
)
</code></pre>
<blockquote>
<p>Attention à ne pas confondre une option <em>"-D..."</em> passé en ligne de commande à cmake et le <em>"-DTEST"</em> de la commande <em>target_compile_definitions</em>.</p>
</blockquote>
<p>Une option <em>"-D..."</em> de la ligne de commande crée/set une variable que vous pouvez utiliser dans votre CMakeLists.txt pour effectuer divers tests.</p>
<h3 id="retirer-les-symboles-du-binaire">Retirer les symboles du binaire</h3>
<p>La commande <strong><a href="https://cmake.org/cmake/help/latest/command/add_custom_command.html">add_custom_command</a></strong> permet d'ajouter des commandes à executer à une target.</p>
<p>Notez que l'on utilise pas directement l'utilitaire <em>objcopy</em>, mais la variable <em>${CMAKE_OBJCOPY}</em>.</p>
<p>Ces commandes permettent d'extraire les symboles du binaire et de le stocker dans un fichier nommé <em>${PROJECT_NAME}.debug</em>. Et d'associer ce fichier à l'executable.</p>
<blockquote>
<p>Sous Windows avec le compilateur MSVC, ceci ne fonctionne pas. De plus ce n'est pas nécessaire, MSVC strip automatiquement les binaires et place les symboles dans un fichier .pdb</p>
</blockquote>
<p>Il faut donc modifier ce que nous avons écrit plus haut comme suit :</p>
<pre><code>:::cmake
if (${CMAKE_CXX_COMPILER_ID} STREQUAL "GNU")
    # On retire les symboles de l'exécutable
    add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
        COMMAND ${CMAKE_OBJCOPY} --only-keep-debug ${PROJECT_NAME} ${PROJECT_NAME}.debug
        COMMAND ${CMAKE_OBJCOPY} --strip-debug ${PROJECT_NAME}
        COMMAND ${CMAKE_OBJCOPY} --add-gnu-debuglink=${PROJECT_NAME}.debug ${PROJECT_NAME}
    )
endif()
</code></pre>
<h3 id="directive-dinstallation">Directive d'installation</h3>
<p>La commande <strong><a href="https://cmake.org/cmake/help/latest/command/install.html">install</a></strong> ajoute au Makefile généré une cible <em>install</em>, on pourra dès lors invoquer <em>make install</em> ou <em>cmake --install .</em></p>
<p>Le dossier de destination peut être absolu ou relatif. Il est préférable de toujours utiliser un dossier relatif, il sera alors possible
de reloger les fichiers à installer au moment de l'installation.</p>
<p>Si le dossier de destination est un chemin relatif, il sera préfixé par le contenu de la variable <strong>CMAKE_INSTALL_PREFIX</strong>. La valeur par défaut de cette variable est : <em>/usr/local</em> sous UNIX et <em>C:/Program Files/${PROJECT_NAME}</em> sous Windows.</p>
<p>Cette variable peut être définie lors de la configuration du projet <code>cmake -S . -B build -DCMAKE_INSTALL_PREFIX=$HOME/local</code>, mais également au moment de l'installation <code>cmake --install . --prefix $HOME/local</code>. Ces deux commandes installeront votre binaire dans <em>$HOME/local/bin</em>.</p>
<p>Sous UNIX, attention de ne pas confondre le <em>mécanisme</em> DESTIR avec l'<em>INSTALL_PREFIX</em>. L'appel <code>make DESTDIR=/tmp install</code>à pour effet de déplacer l'ensemble de l'installation vers un autre dossier.</p>
<p>Ainsi, si <em>CMAKE_INSTALL_PREFIX=/opt/MyCompany</em>, <em>make DESTIR=/tmp install</em> installera votre projet dans <em>/tmp/opt/MyCompany</em>.</p>
<p>Le module <em>GNUInstallDirs</em> fournit un ensemble de variables permettant de respecter le style d'organisation des dossiers GNU. On les utilisera dans pour les bibliothèques.</p>
<h3 id="reecriture-portable-du-cmakeliststtxt">Réécriture portable du CMakeListst.txt</h3>
<pre><code>:::cmake
cmake_minimum_required(VERSION 3.0.2)
project(app04 VERSION 1.2.3.4 LANGUAGES CXX)

# Définition de la target
add_executable(
    ${PROJECT_NAME}
    main.cpp
    pipotron.cpp
    pipotron.h
)

# CXXFLAGS : Flags passés au compilateur
target_compile_options( ${PROJECT_NAME}
    PRIVATE
        # GCC Flags
        $&lt;$&lt;CXX_COMPILER_ID:GNU&gt;:-Wall -Wextra&gt;
        $&lt;$&lt;AND:$&lt;CONFIG:DEBUG&gt;,$&lt;CXX_COMPILER_ID:GNU&gt;&gt;:-O0 -ggdb&gt;
        $&lt;$&lt;AND:$&lt;CONFIG:RELEASE&gt;,$&lt;CXX_COMPILER_ID:GNU&gt;&gt;:-O2 -ggdb&gt;

        # MSVC Flags
        $&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;: /W4 /WX&gt;
        $&lt;$&lt;AND:$&lt;CONFIG:DEBUG&gt;,$&lt;CXX_COMPILER_ID:MSVC&gt;&gt;: /Od&gt;
        $&lt;$&lt;AND:$&lt;CONFIG:RELEASE&gt;,$&lt;CXX_COMPILER_ID:MSVC&gt;&gt;: /O2&gt;
)

# On force l'utilisation de C++11
set_target_properties( ${PROJECT_NAME}
    PROPERTIES 
        CXX_STANDARD          11
        CXX_STANDARD_REQUIRED YES
)

# Ajout d'un define, équivalent g++ -DDEBUG
target_compile_definitions( ${PROJECT_NAME}
    PRIVATE
        $&lt;$&lt;CONFIG:DEBUG&gt;:DEBUG&gt;    # Ajoute -DDEBUG uniquement en mode Debug
)

if (${CMAKE_CXX_COMPILER_ID} STREQUAL "GNU")
    # On retire les symboles de l'exécutable
    add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
        COMMAND ${CMAKE_OBJCOPY} --only-keep-debug ${PROJECT_NAME} ${PROJECT_NAME}.debug
        COMMAND ${CMAKE_OBJCOPY} --strip-debug ${PROJECT_NAME}
        COMMAND ${CMAKE_OBJCOPY} --add-gnu-debuglink=${PROJECT_NAME}.debug ${PROJECT_NAME}
    )
endif()

# Directive d'installation
install(
    TARGETS         ${PROJECT_NAME}
    DESTINATION     bin
)
</code></pre>
<h1 id="6-outils-du-langage-cmake">6 Outils du langage cmake</h1>
<h2 id="61-variables">6.1 Variables</h2>
<p>CMake nous permet de définir des variables avec la syntaxe <strong><a href="https://cmake.org/cmake/help/latest/command/set.html">set</a>( nom-de-variable valeur )</strong>. Le nom d'une variable est case sensitive. <strong>${nom-de-variable}</strong> permet d'utiliser le contenu d'une variable.</p>
<pre><code>:::cmake
set( VAR toto )         # La variable VAR contient toto
set( VAR titi )         # La variable VAR contient titi, on à écrasé l'ancienne valeur.
set( VAR toto titi )    # La variable VAR contient la liste toto;titi
set( VAR ${VAR} tutu )  # La variable VAR contient la liste toto;titi;tutu; (concaténation)
</code></pre>
<p>CMake se réserve les variables commençant par :</p>
<ul>
<li>cmake (upper case, lower case ou mixed case),</li>
<li>_cmake (upper case, lower case ou mixed case),</li>
<li>_ suivi d'un nom de commande.</li>
</ul>
<p>La portée d'une variable est :</p>
<ul>
<li>soit la fonction dans laquelle est définie;</li>
<li>soit le fichier CMakeLists.txt (et donc dossier contenant ce fichier) si elle définie hors d'une fonction;</li>
<li>soit persistante dans le cache.</li>
</ul>
<p>L'option <strong>PARENT_SCOPE</strong> permet de définir la variable dans la portée de niveau supérieur.</p>
<p>CMake stocke un ensemble de variables de manière persistante dans le fichier de cache CMakeCache.txt. Les variables du cache on un scope globale et nécessite d'utiliser l'option CACHE de la commande <em>set</em> pour être modifiées. La syntaxe est : <code>set( variable valeur CACHE &lt;TYPE&gt; "DESCRIPTION" [FORCE] )</code>.</p>
<p>Pour une variable stockée dans le cache, il faut préciser son type :</p>
<ul>
<li>BOOL : booléen, valeurs : ON/OFF.</li>
<li>FILEPATH : chemin d'un fichier sur le disque.</li>
<li>PATH : chemin d'un dossier.</li>
<li>STRING : une ligne de texte.</li>
<li>INTERNAL : une ligne de texte, mais qui ne sera pas affichée dans le cmake-gui. Ce type de variable requière l'option force.</li>
</ul>
<p>La description doit également être présente, des guillemets vide sont suffisant.</p>
<p>L'option <em>FORCE</em> permet d'écraser la valeur d'une variable déjà présente dans le cache.</p>
<h2 id="62-les-listes">6.2 Les listes</h2>
<p><a href="https://cmake.org/cmake/help/latest/command/list.html">list</a>(APPEND
)</p>
<h2 id="63-afficher-des-messages">6.3 Afficher des messages</h2>
<p>message(STATUS "Mon message")</p>
<h2 id="64-generation-de-fichiers">6.4 Génération de fichiers</h2>
<p>configure_file(
    ${CMAKE_CURRENT_SOURCE_DIR}/config.h.in
    ${CMAKE_CURRENT_BINARY_DIR}/config.h
)</p>
<h2 id="65-gestion-doptions">6.5 Gestion d'options</h2>
<p>option(ENABLE_YYYY "Enable YYYY" OFF)</p>
<h2 id="66-les-conditions">6.6 Les conditions</h2>
<h2 id="67-custom_target">6.7 custom_target</h2>
<h1 id="7-une-application-qui-utilise-des-bibliotheques">7 Une application qui utilise des bibliothèques</h1>
<h3 id="find_library">find_library</h3>
<h3 id="find_package">find_package</h3>
<h3 id="bibliotheques-third-party">Bibliothèques "third party"</h3>
<h1 id="8-creer-une-bibliotheques">8 Créer une bibliothèques</h1>
<h2 id="81-statique-ou-partagee">8.1 Statique ou partagée</h2>
<h2 id="82-statique-et-partagee">8.2 Statique et partagée</h2>
<h2 id="83-visibilite-des-symboles-dune-bibliotheques-partagee">8.3 Visibilité des symboles d'une bibliothèques partagée</h2>
<h2 id="84-exporter-sa-bibliotheque">8.4 Exporter sa bibliothèque</h2>
<h2 id="85-une-bibliotheque-avec-dependances">8.5 Une bibliothèque avec dépendances</h2>
<h1 id="9-tests-unitaires">9 Tests unitaires</h1>
<h1 id="10-documentation">10 Documentation</h1>
<h1 id="11-packaging">11 Packaging</h1>
<h1 id="12-ne-pas-deployer-projet-de-projet">12 Ne pas déployer (Projet de projet)</h1>
<h1 id="13-organisation-des-sources">13 Organisation des sources</h1>
<h3 id="avant-314">Avant 3.14</h3>
<h3 id="apres-314">Après 3.14</h3>
<h1 id="14-macros-et-fonctions">14 Macros et fonctions</h1>
<h1 id="15-parser-un-fichier">15 Parser un fichier</h1>
<h1 id="5-portee-des-variables-commandes-et-proprietes">5. Portée des variables, commandes et propriétés</h1>
<p>Lorsque l'on set une variable, une propriété ou utilise une commande, elles ont un certain champs d'action que l'on nomme <em>portée</em>.</p>
<p>Prenons en exemple les commandes <em>target_compile_options</em> et <em>add_compile_options</em>.
Ces deux commandes ont le même rôle, mais pas le même portée.</p>
<p><em>target_compile_options</em> ajoute des options uniquement à une target, tandis que <em>add_compile_options</em> ajoute des options à toutes les targets du répertoire courant et des sous-répertoires ajoutés après.</p>
<p>Pour l'exemple suivant, j'ai utilisé le fichier main.cpp de exp01.</p>
<pre><code>:::cmake
cmake_minimum_required(VERSION 3.0.2)
project(app03 VERSION 1.2.3.4 LANGUAGES CXX)

add_executable(target1 main.cpp)

add_compile_options(-werror)

add_executable(target2 main.cpp)
add_executable(target3 main.cpp)

target_compile_options(target1 PRIVATE -Wall -Wextra)
target_compile_options(target2 PRIVATE -Wall -Wextra)

get_property(G_CO DIRECTORY PROPERTY COMPILE_OPTIONS)
get_target_property(T1_CO target1 COMPILE_OPTIONS)
get_target_property(T2_CO target2 COMPILE_OPTIONS)
get_target_property(T3_CO target3 COMPILE_OPTIONS)

message(STATUS "COMPILE_OPTIONS        : ${G_CO}")
message(STATUS "target1 compile options: ${T1_CO}")
message(STATUS "target2 compile options: ${T2_CO}")
message(STATUS "target3 compile options: ${T3_CO}")

:::console
$ cmake ..
-- COMPILE_OPTIONS        : -werror
-- target1 compile options: -Wall;-Wextra
-- target2 compile options: -werror;-Wall;-Wextra
-- target3 compile options: -werror
-- Configuring done
-- Generating done
</code></pre>
<p>On constate que la ligne <em>add_compile_options(-werror)</em> n'a pas modifié la target1 crée juste avant, mais bien les targets 2 et 3.</p>
<p>Il est déconseillé d'utiliser les commandes non préfixées par <em>target</em> ou d'assigner une variable à portée globale. Dans un projet vous pourriez être amener à inclure d'autre CMakeLists.txt et donc modifier des paramètres sans le vouloir.</p>
  </div>
  <header><p>
        <br>Série  :
  </p></header>
  <div class="tag-cloud">
    <p>
      <span class="fa fa-tags" ></span> 
      <a href="https://thebigfred.github.io/tag/cmd-line.html">cmd-line</a>
      <a href="https://thebigfred.github.io/tag/gnu-tools.html">GNU-Tools</a>
    </p>
  </div>





<!-- gittalk -->
<div id="gitalk-container"></div>
<script type="text/javascript">
	const gitalk = new Gitalk({
		clientID: 'ff500cd58d3176eccb54',
		clientSecret: 'c5f7d6a38b1cc73dea3b02a075e8630eaad15617',
		repo: 'comments',      // The repository of store comments,
		owner: 'TheBigFred',
		admin: ['TheBigFred'],
		id: 'Introduction à CMake',      // Ensure uniqueness and length less than 50
		distractionFreeMode: false  // Facebook-like distraction free mode
	})

	gitalk.render('gitalk-container')
</script>
<noscript>
    Veuillez activer le JavaScript pour voir les commentaires.
</noscript>
<!-- End gittalk -->
</article>

    <footer>
<p>
  &copy; FGE 2016 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Propulsé par <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> thème par <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " fgeDoc's ",
  "url" : "https://thebigfred.github.io",
  "image": "",
  "description": "FGE's Thoughts and Writings"
}
</script>

</body>
</html>